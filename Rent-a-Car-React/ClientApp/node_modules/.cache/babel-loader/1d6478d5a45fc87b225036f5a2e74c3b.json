{"ast":null,"code":"import { UserManager, WebStorageStateStore } from 'oidc-client';\nimport { ApplicationPaths, ApplicationName } from './ApiAuthorizationConstants';\nexport class AuthorizeService {\n  constructor() {\n    this._callbacks = [];\n    this._nextSubscriptionId = 0;\n    this._user = null;\n    this._isAuthenticated = false;\n    this._accountType = null;\n    this._popUpDisabled = true;\n  }\n\n  async isAuthenticated() {\n    const user = await this.getUser();\n    return !!user;\n  }\n\n  async getUser() {\n    if (this._user && this._user.profile) {\n      return this._user.profile;\n    }\n\n    await this.ensureUserManagerInitialized();\n    const user = await this.userManager.getUser();\n    return user && user.profile;\n  }\n\n  async getAccountType() {\n    const user = await this.getUser();\n\n    if (!!user) {\n      try {\n        const token = await authService.getAccessToken();\n        const response = await fetch(process.env.REACT_APP_API + '/CarApiPrivate/GetAccountType/' + user.name, {\n          headers: !token ? {} : {\n            'Authorization': `Bearer ${token}`\n          }\n        });\n        const responseJson = await response.json();\n        this._accountType = responseJson[0].accountType;\n      } catch {\n        this._accountType = null;\n      }\n\n      return this._accountType;\n    } else {\n      this._accountType = null;\n      console.log(this._accountType);\n      return null;\n    }\n  }\n\n  async getAccessToken() {\n    await this.ensureUserManagerInitialized();\n    const user = await this.userManager.getUser();\n    return user && user.access_token;\n  } // We try to authenticate the user in three different ways:\n  // 1) We try to see if we can authenticate the user silently. This happens\n  //    when the user is already logged in on the IdP and is done using a hidden iframe\n  //    on the client.\n  // 2) We try to authenticate the user using a PopUp Window. This might fail if there is a\n  //    Pop-Up blocker or the user has disabled PopUps.\n  // 3) If the two methods above fail, we redirect the browser to the IdP to perform a traditional\n  //    redirect flow.\n\n\n  async signIn(state) {\n    await this.ensureUserManagerInitialized();\n\n    try {\n      const silentUser = await this.userManager.signinSilent(this.createArguments());\n      this.updateState(silentUser);\n      return this.success(state);\n    } catch (silentError) {\n      // User might not be authenticated, fallback to popup authentication\n      console.log(\"Silent authentication error: \", silentError);\n\n      try {\n        if (this._popUpDisabled) {\n          throw new Error('Popup disabled. Change \\'AuthorizeService.js:AuthorizeService._popupDisabled\\' to false to enable it.');\n        }\n\n        const popUpUser = await this.userManager.signinPopup(this.createArguments());\n        this.updateState(popUpUser);\n        return this.success(state);\n      } catch (popUpError) {\n        if (popUpError.message === \"Popup window closed\") {\n          // The user explicitly cancelled the login action by closing an opened popup.\n          return this.error(\"The user closed the window.\");\n        } else if (!this._popUpDisabled) {\n          console.log(\"Popup authentication error: \", popUpError);\n        } // PopUps might be blocked by the user, fallback to redirect\n\n\n        try {\n          await this.userManager.signinRedirect(this.createArguments(state));\n          return this.redirect();\n        } catch (redirectError) {\n          console.log(\"Redirect authentication error: \", redirectError);\n          return this.error(redirectError);\n        }\n      }\n    }\n  }\n\n  async completeSignIn(url) {\n    try {\n      await this.ensureUserManagerInitialized();\n      const user = await this.userManager.signinCallback(url);\n      this.updateState(user);\n      return this.success(user && user.state);\n    } catch (error) {\n      console.log('There was an error signing in: ', error);\n      return this.error('There was an error signing in.');\n    }\n  } // We try to sign out the user in two different ways:\n  // 1) We try to do a sign-out using a PopUp Window. This might fail if there is a\n  //    Pop-Up blocker or the user has disabled PopUps.\n  // 2) If the method above fails, we redirect the browser to the IdP to perform a traditional\n  //    post logout redirect flow.\n\n\n  async signOut(state) {\n    await this.ensureUserManagerInitialized();\n\n    try {\n      if (this._popUpDisabled) {\n        throw new Error('Popup disabled. Change \\'AuthorizeService.js:AuthorizeService._popupDisabled\\' to false to enable it.');\n      }\n\n      await this.userManager.signoutPopup(this.createArguments());\n      this.updateState(undefined);\n      return this.success(state);\n    } catch (popupSignOutError) {\n      console.log(\"Popup signout error: \", popupSignOutError);\n\n      try {\n        await this.userManager.signoutRedirect(this.createArguments(state));\n        return this.redirect();\n      } catch (redirectSignOutError) {\n        console.log(\"Redirect signout error: \", redirectSignOutError);\n        return this.error(redirectSignOutError);\n      }\n    }\n  }\n\n  async completeSignOut(url) {\n    await this.ensureUserManagerInitialized();\n\n    try {\n      const response = await this.userManager.signoutCallback(url);\n      this.updateState(null);\n      return this.success(response && response.data);\n    } catch (error) {\n      console.log(`There was an error trying to log out '${error}'.`);\n      return this.error(error);\n    }\n  }\n\n  updateState(user) {\n    this._user = user;\n    this._isAuthenticated = !!this._user;\n    this.notifySubscribers();\n  }\n\n  subscribe(callback) {\n    this._callbacks.push({\n      callback,\n      subscription: this._nextSubscriptionId++\n    });\n\n    return this._nextSubscriptionId - 1;\n  }\n\n  unsubscribe(subscriptionId) {\n    const subscriptionIndex = this._callbacks.map((element, index) => element.subscription === subscriptionId ? {\n      found: true,\n      index\n    } : {\n      found: false\n    }).filter(element => element.found === true);\n\n    if (subscriptionIndex.length !== 1) {\n      throw new Error(`Found an invalid number of subscriptions ${subscriptionIndex.length}`);\n    }\n\n    this._callbacks.splice(subscriptionIndex[0].index, 1);\n  }\n\n  notifySubscribers() {\n    for (let i = 0; i < this._callbacks.length; i++) {\n      const callback = this._callbacks[i].callback;\n      callback();\n    }\n  }\n\n  createArguments(state) {\n    return {\n      useReplaceToNavigate: true,\n      data: state\n    };\n  }\n\n  error(message) {\n    return {\n      status: AuthenticationResultStatus.Fail,\n      message\n    };\n  }\n\n  success(state) {\n    return {\n      status: AuthenticationResultStatus.Success,\n      state\n    };\n  }\n\n  redirect() {\n    return {\n      status: AuthenticationResultStatus.Redirect\n    };\n  }\n\n  async ensureUserManagerInitialized() {\n    if (this.userManager !== undefined) {\n      return;\n    }\n\n    let response = await fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);\n\n    if (!response.ok) {\n      throw new Error(`Could not load settings for '${ApplicationName}'`);\n    }\n\n    let settings = await response.json();\n    settings.automaticSilentRenew = true;\n    settings.includeIdTokenInSilentRenew = true;\n    settings.userStore = new WebStorageStateStore({\n      prefix: ApplicationName\n    });\n    this.userManager = new UserManager(settings);\n    this.userManager.events.addUserSignedOut(async () => {\n      await this.userManager.removeUser();\n      this.updateState(undefined);\n    });\n  }\n\n  static get instance() {\n    return authService;\n  }\n\n}\nconst authService = new AuthorizeService();\nexport default authService;\nexport const AuthenticationResultStatus = {\n  Redirect: 'redirect',\n  Success: 'success',\n  Fail: 'fail'\n};","map":{"version":3,"sources":["C:/Users/bluec/Desktop/Nowy folder (3)/Rent-a-Car-React/ClientApp/src/components/api-authorization/AuthorizeService.js"],"names":["UserManager","WebStorageStateStore","ApplicationPaths","ApplicationName","AuthorizeService","_callbacks","_nextSubscriptionId","_user","_isAuthenticated","_accountType","_popUpDisabled","isAuthenticated","user","getUser","profile","ensureUserManagerInitialized","userManager","getAccountType","token","authService","getAccessToken","response","fetch","process","env","REACT_APP_API","name","headers","responseJson","json","accountType","console","log","access_token","signIn","state","silentUser","signinSilent","createArguments","updateState","success","silentError","Error","popUpUser","signinPopup","popUpError","message","error","signinRedirect","redirect","redirectError","completeSignIn","url","signinCallback","signOut","signoutPopup","undefined","popupSignOutError","signoutRedirect","redirectSignOutError","completeSignOut","signoutCallback","data","notifySubscribers","subscribe","callback","push","subscription","unsubscribe","subscriptionId","subscriptionIndex","map","element","index","found","filter","length","splice","i","useReplaceToNavigate","status","AuthenticationResultStatus","Fail","Success","Redirect","ApiAuthorizationClientConfigurationUrl","ok","settings","automaticSilentRenew","includeIdTokenInSilentRenew","userStore","prefix","events","addUserSignedOut","removeUser","instance"],"mappings":"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","sourcesContent":["import { UserManager, WebStorageStateStore } from 'oidc-client';\r\nimport { ApplicationPaths, ApplicationName } from './ApiAuthorizationConstants';\r\n\r\nexport class AuthorizeService {\r\n    _callbacks = [];\r\n    _nextSubscriptionId = 0;\r\n    _user = null;\r\n    _isAuthenticated = false;\r\n    _accountType = null;\r\n    // By default pop ups are disabled because they don't work properly on Edge.\r\n    // If you want to enable pop up authentication simply set this flag to false.\r\n    _popUpDisabled = true;\r\n\r\n    async isAuthenticated() {\r\n        const user = await this.getUser();\r\n        return !!user;\r\n    }\r\n\r\n    async getUser() {\r\n        if (this._user && this._user.profile) {\r\n            return this._user.profile;\r\n        }\r\n        await this.ensureUserManagerInitialized();\r\n        const user = await this.userManager.getUser();\r\n        return user && user.profile;\r\n    }\r\n\r\n    async getAccountType() {\r\n        const user = await this.getUser();\r\n        if (!!user) {               \r\n            try {\r\n                const token = await authService.getAccessToken();\r\n                const response = await fetch(process.env.REACT_APP_API + '/CarApiPrivate/GetAccountType/' + user.name, {\r\n                    headers: !token ? {} : { 'Authorization': `Bearer ${token}` }\r\n                });\r\n                const responseJson = await response.json();\r\n                this._accountType = responseJson[0].accountType;\r\n            } catch {\r\n                this._accountType = null;\r\n            }\r\n   \r\n            return this._accountType;\r\n\r\n        } else {\r\n            this._accountType = null;\r\n            console.log(this._accountType);\r\n            return null;\r\n        }\r\n    }\r\n    async getAccessToken() {\r\n        await this.ensureUserManagerInitialized();\r\n        const user = await this.userManager.getUser();\r\n        return user && user.access_token;\r\n    }\r\n\r\n    // We try to authenticate the user in three different ways:\r\n    // 1) We try to see if we can authenticate the user silently. This happens\r\n    //    when the user is already logged in on the IdP and is done using a hidden iframe\r\n    //    on the client.\r\n    // 2) We try to authenticate the user using a PopUp Window. This might fail if there is a\r\n    //    Pop-Up blocker or the user has disabled PopUps.\r\n    // 3) If the two methods above fail, we redirect the browser to the IdP to perform a traditional\r\n    //    redirect flow.\r\n    async signIn(state) {\r\n        await this.ensureUserManagerInitialized();\r\n        try {\r\n            const silentUser = await this.userManager.signinSilent(this.createArguments());\r\n            this.updateState(silentUser);\r\n            return this.success(state);\r\n        } catch (silentError) {\r\n            // User might not be authenticated, fallback to popup authentication\r\n            console.log(\"Silent authentication error: \", silentError);\r\n\r\n            try {\r\n                if (this._popUpDisabled) {\r\n                    throw new Error('Popup disabled. Change \\'AuthorizeService.js:AuthorizeService._popupDisabled\\' to false to enable it.')\r\n                }\r\n\r\n                const popUpUser = await this.userManager.signinPopup(this.createArguments());\r\n                this.updateState(popUpUser);\r\n                return this.success(state);\r\n            } catch (popUpError) {\r\n                if (popUpError.message === \"Popup window closed\") {\r\n                    // The user explicitly cancelled the login action by closing an opened popup.\r\n                    return this.error(\"The user closed the window.\");\r\n                } else if (!this._popUpDisabled) {\r\n                    console.log(\"Popup authentication error: \", popUpError);\r\n                }\r\n\r\n                // PopUps might be blocked by the user, fallback to redirect\r\n                try {\r\n                    await this.userManager.signinRedirect(this.createArguments(state));\r\n                    return this.redirect();\r\n                } catch (redirectError) {\r\n                    console.log(\"Redirect authentication error: \", redirectError);\r\n                    return this.error(redirectError);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async completeSignIn(url) {\r\n        try {\r\n            await this.ensureUserManagerInitialized();\r\n            const user = await this.userManager.signinCallback(url);\r\n            this.updateState(user);\r\n            return this.success(user && user.state);\r\n        } catch (error) {\r\n            console.log('There was an error signing in: ', error);\r\n            return this.error('There was an error signing in.');\r\n        }\r\n    }\r\n\r\n    // We try to sign out the user in two different ways:\r\n    // 1) We try to do a sign-out using a PopUp Window. This might fail if there is a\r\n    //    Pop-Up blocker or the user has disabled PopUps.\r\n    // 2) If the method above fails, we redirect the browser to the IdP to perform a traditional\r\n    //    post logout redirect flow.\r\n    async signOut(state) {\r\n        await this.ensureUserManagerInitialized();\r\n        try {\r\n            if (this._popUpDisabled) {\r\n                throw new Error('Popup disabled. Change \\'AuthorizeService.js:AuthorizeService._popupDisabled\\' to false to enable it.')\r\n            }\r\n\r\n            await this.userManager.signoutPopup(this.createArguments());\r\n            this.updateState(undefined);\r\n            return this.success(state);\r\n        } catch (popupSignOutError) {\r\n            console.log(\"Popup signout error: \", popupSignOutError);\r\n            try {\r\n                await this.userManager.signoutRedirect(this.createArguments(state));\r\n                return this.redirect();\r\n            } catch (redirectSignOutError) {\r\n                console.log(\"Redirect signout error: \", redirectSignOutError);\r\n                return this.error(redirectSignOutError);\r\n            }\r\n        }\r\n    }\r\n\r\n    async completeSignOut(url) {\r\n        await this.ensureUserManagerInitialized();\r\n        try {\r\n            const response = await this.userManager.signoutCallback(url);\r\n            this.updateState(null);\r\n            return this.success(response && response.data);\r\n        } catch (error) {\r\n            console.log(`There was an error trying to log out '${error}'.`);\r\n            return this.error(error);\r\n        }\r\n    }\r\n\r\n    updateState(user) {\r\n        this._user = user;\r\n        this._isAuthenticated = !!this._user;\r\n        this.notifySubscribers();\r\n    }\r\n\r\n    subscribe(callback) {\r\n        this._callbacks.push({ callback, subscription: this._nextSubscriptionId++ });\r\n        return this._nextSubscriptionId - 1;\r\n    }\r\n\r\n    unsubscribe(subscriptionId) {\r\n        const subscriptionIndex = this._callbacks\r\n            .map((element, index) => element.subscription === subscriptionId ? { found: true, index } : { found: false })\r\n            .filter(element => element.found === true);\r\n        if (subscriptionIndex.length !== 1) {\r\n            throw new Error(`Found an invalid number of subscriptions ${subscriptionIndex.length}`);\r\n        }\r\n\r\n        this._callbacks.splice(subscriptionIndex[0].index, 1);\r\n    }\r\n\r\n    notifySubscribers() {\r\n        for (let i = 0; i < this._callbacks.length; i++) {\r\n            const callback = this._callbacks[i].callback;\r\n            callback();\r\n        }\r\n    }\r\n\r\n    createArguments(state) {\r\n        return { useReplaceToNavigate: true, data: state };\r\n    }\r\n\r\n    error(message) {\r\n        return { status: AuthenticationResultStatus.Fail, message };\r\n    }\r\n\r\n    success(state) {\r\n        return { status: AuthenticationResultStatus.Success, state };\r\n    }\r\n\r\n    redirect() {\r\n        return { status: AuthenticationResultStatus.Redirect };\r\n    }\r\n\r\n    async ensureUserManagerInitialized() {\r\n        if (this.userManager !== undefined) {\r\n            return;\r\n        }\r\n\r\n        let response = await fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);\r\n        if (!response.ok) {\r\n            throw new Error(`Could not load settings for '${ApplicationName}'`);\r\n        }\r\n\r\n        let settings = await response.json();\r\n        settings.automaticSilentRenew = true;\r\n        settings.includeIdTokenInSilentRenew = true;\r\n        settings.userStore = new WebStorageStateStore({\r\n            prefix: ApplicationName\r\n        });\r\n\r\n        this.userManager = new UserManager(settings);\r\n\r\n        this.userManager.events.addUserSignedOut(async () => {\r\n            await this.userManager.removeUser();\r\n            this.updateState(undefined);\r\n        });\r\n    }\r\n\r\n    static get instance() { return authService }\r\n}\r\n\r\nconst authService = new AuthorizeService();\r\n\r\nexport default authService;\r\n\r\nexport const AuthenticationResultStatus = {\r\n    Redirect: 'redirect',\r\n    Success: 'success',\r\n    Fail: 'fail'\r\n};\r\n"]},"metadata":{},"sourceType":"module"}